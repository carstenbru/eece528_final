
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module PROYECT_FINAL(

	//////////// CLOCK //////////
	CLOCK_50,

	//////////// LED //////////
	LED,

	//////////// KEY //////////
	KEY,

	//////////// SW //////////
	SW,

	//////////// SDRAM //////////
	DRAM_ADDR,
	DRAM_BA,
	DRAM_CAS_N,
	DRAM_CKE,
	DRAM_CLK,
	DRAM_CS_N,
	DRAM_DQ,
	DRAM_DQM,
	DRAM_RAS_N,
	DRAM_WE_N,

	//////////// EEPROM //////////
	I2C_SCLK,
	I2C_SDAT,

	//////////// 2x13 GPIO Header //////////
	GPIO_2,
	GPIO_2_IN,

	//////////// GPIO_0, GPIO_0 connect to GPIO Default //////////
	GPIO,
	GPIO_IN,

	//////////// GPIO_1, GPIO_1 connect to GPIO Default //////////
	GPIO1,
	GPIO1_IN 
);

//=======================================================
//  PARAMETER declarations
//=======================================================


//=======================================================
//  PORT declarations
//=======================================================

//////////// CLOCK //////////
input 		          		CLOCK_50;

//////////// LED //////////
output		     [7:0]		LED;

//////////// KEY //////////
input 		     [1:0]		KEY;

//////////// SW //////////
input 		     [3:0]		SW;

//////////// SDRAM //////////
output		    [12:0]		DRAM_ADDR;
output		     [1:0]		DRAM_BA;
output		          		DRAM_CAS_N;
output		          		DRAM_CKE;
output		          		DRAM_CLK;
output		          		DRAM_CS_N;
inout 		    [15:0]		DRAM_DQ;
output		     [1:0]		DRAM_DQM;
output		          		DRAM_RAS_N;
output		          		DRAM_WE_N;

//////////// EEPROM //////////
output		          		I2C_SCLK;
inout 		          		I2C_SDAT;

//////////// 2x13 GPIO Header //////////
inout 		    [12:0]		GPIO_2;
input 		     [2:0]		GPIO_2_IN;

//////////// GPIO_0, GPIO_0 connect to GPIO Default //////////
inout 		    [33:0]		GPIO;
input 		     [1:0]		GPIO_IN;

//////////// GPIO_1, GPIO_1 connect to GPIO Default //////////
inout 		    [33:0]		GPIO1;
input 		     [1:0]		GPIO1_IN;


//=======================================================
//  REG/WIRE declarations
//=======================================================

//TOUCHSCREEN 
wire TFT_ADC_BUSY;
wire TFT_ADC_PENIRQ_N;
wire TFT_ADC_DOUT;
wire TFT_ADC_DIN;
wire TFT_ADC_DCLK;
wire TFT_ADC_CS_N;


wire sdram_clk;
wire sys_clk;
wire clock_10MHz;
wire reset_n;

wire TFT_BACKLIGHT;//PWM
wire TFT_DSIP;
wire TFT_DCLK;
wire TFT_VSYNC;
wire TFT_HSYNC;
wire TFT_DE;
wire [7:0]TFT_RED;
wire [7:0]TFT_GREEN;
wire [7:0]TFT_BLUE;





wire frac_start;
wire [31:0] cx;
wire [31:0] cy;
wire [15:0] maxit;
wire [15:0] iter_sig;
wire frac_idle;

//=======================================================
//  Structural coding
//=======================================================




assign DRAM_CLK=sdram_clk;


pll_system	pll_system_inst (
		.inclk0(CLOCK_50) ,	// input  inclk0_sig
	.c0(sys_clk) ,	// output  c0_sig 150 MHZ
	.c1(sdram_clk) ,	// output  c1_sig
	.c2(clock_10MHz) ,	// output  c2_sig
	.c3(TFT_DCLK),
	.locked(reset_n) 	// output  locked_sig
	);

	
	

system u0 (
        .clk_clk              (sys_clk),              //           clk.clk
        .reset_reset_n        (reset_n),        //         reset.reset_n
	

			//EPCS		
        .epcs_sdo             (EPCS_ASDO),             //          epcs.sdo
        .epcs_data0           (EPCS_DATA0),           //              .data0
        .epcs_dclk            (EPCS_DCLK),            //              .dclk
       .epcs_sce             (EPCS_NCSO),             //              .sce
	
			//SDRAM
        .sdram_dqm            (DRAM_DQM),            //         sdram.dqm
        .sdram_ras_n          (DRAM_RAS_N),          //              .ras_n
        .sdram_cs_n           (DRAM_CS_N),           //              .cs_n
        .sdram_we_n           (DRAM_WE_N),           //              .we_n
        .sdram_dq             (DRAM_DQ),             //              .dq
        .sdram_cke            (DRAM_CKE),            //              .cke
        .sdram_addr           (DRAM_ADDR),           //              .addr
        .sdram_ba             (DRAM_BA),             //              .ba
        .sdram_cas_n          (DRAM_CAS_N),          //              .cas_n
		  
		  //Touch Screen SPI
		  .touch_panel_spi_MISO        (TFT_ADC_DOUT),        //      touch_panel_spi.MISO
        .touch_panel_spi_MOSI        (TFT_ADC_DIN),        //                     .MOSI
        .touch_panel_spi_SS_n        (TFT_ADC_CS_N),        //                     .SS_n
        .touch_panel_spi_SCLK        (TFT_ADC_DCLK),        //                     .SCLK
        .touch_panel_busy_export     (TFT_ADC_BUSY),     //     touch_panel_busy.export
        .touch_panel_penirq_n_export (TFT_ADC_PENIRQ_N),  
		  
		  //LED & SW
        .pio_led_green_export (), // pio_led_green.export
        .pio_sw_export        (SW[3:0]),
		  
		   .alt_vip_itc_0_clocked_video_vid_h_sync    (TFT_HSYNC),    //                            .vid_h_sync
        .alt_vip_itc_0_clocked_video_vid_clk       (TFT_DCLK),       //                            .vid_clkid_v
        .alt_vip_itc_0_clocked_video_vid_data      ({TFT_RED,TFT_GREEN,TFT_BLUE}),      //                            .vid_data
        .alt_vip_itc_0_clocked_video_vid_v_sync    (TFT_VSYNC),    //                            .vid_v_sync
        .alt_vip_itc_0_clocked_video_vid_datavalid (TFT_DE), //                            .vid_datavalid

			.boton_a_export      (button_x ),                            //                     boton_a.export
        .boton_b_export       (circle ),                            //                     boton_b.export
        .boton_x_export       (square),                            //                     boton_x.export
        .boton_y_export       (triangle ),                            //                     boton_y.export
        .boton_l_export       (),                            //                     boton_l.export
        .boton_r_export       (),                            //                     boton_r.export
        .boton_down_export    (arrow_down ),                         //                  boton_down.export
        .boton_left_export    (arrow_left ),                         //                  boton_left.export
        .boton_up_export      (arrow_up ),                           //                    boton_up.export
        .boton_right_export   (arrow_right ),                         //                 boton_right.export
			.analog2_y_export                          (analog2_up_down),                          //                   analog2_y.export
        .analog2_x_export                          (analog2_left_right),                          //                   analog2_x.export
        .analog1_y_export                          (analog1_up_down),                          //                   analog1_y.export
        .analog1_x_export                          (analog1_left_right)                           //                   analog1_x.export
    );

	 
	 
	 

	
		  
 
		  
   

// SNES
wire reset_nes;
wire clk_166;
wire boton_a;
wire boton_b;
wire boton_down;
wire boton_up;
wire boton_left;
wire boton_right;
wire boton_y;
wire boton_x;
wire boton_l;
wire boton_r;



pllnesl	pllnesl_inst (
	
	.inclk0 (CLOCK_50),
	.c0 ( clk_166 ),
	.locked ( reset_nes)
	);

	
	
	// CONTROL
	
	
/*NO MODIFICAR*/
wire dir=1'b0;
assign GPIO1[25] =  dir ? 1'b0 : 1'bz ;
assign GPIO1[29] =  dir ? 1'b0 : 1'bz ;
// Cableado del control de PS2
wire DATA_PSX;
wire CMD_PSX;
wire ATT_PSX;// CS
wire CLK_PSX;
wire ACK_PSX;
assign DATA_PSX=GPIO1[25];
assign GPIO1[24]=CMD_PSX;
assign GPIO1[27]=ATT_PSX;
assign GPIO1[26]=CLK_PSX;
assign ACK_PSX=GPIO1[29];


// BUTTONS PSX
wire arrow_up;
wire arrow_down;
wire arrow_left;
wire arrow_right;

wire select;
wire start;
wire l3;
wire r3;
wire l1;
wire r1;
wire l2;
wire r2;
wire triangle;
wire square;
wire circle;
wire button_x;

wire [7:0]analog1_left_right;
wire [7:0]analog2_left_right;
wire [7:0]analog1_up_down;
wire [7:0]analog2_up_down;


	
	
	
psx_control psx_control_inst
(
	.clk_50mhz(CLOCK_50) ,	// input  clk_250k_sig
	.I_psRXD(DATA_PSX) ,	// input  I_psRXD_sig
	.O_psCLK(CLK_PSX) ,	// output  O_psCLK_sig
	.O_psSEL(ATT_PSX) ,	// output  O_psSEL_sig
	.O_psTXD(CMD_PSX) ,	// output  O_psTXD_sig
	.O_l1(l1) ,	// output  O_l1_sig
	.O_l2(l2) ,	// output  O_l2_sig
	.O_r1(r1) ,	// output  O_r1_sig
	.O_r2(r2) ,	// output  O_r2_sig
	.O_l3(l3) ,	// output  O_l3_sig
	.O_r3(r3) ,	// output  O_r3_sig
	.O_d_pad_up(arrow_up) ,	// output  O_d_pad_up_sig
	.O_d_pad_down(arrow_down) ,	// output  O_d_pad_down_sig
	.O_d_pad_left(arrow_left) ,	// output  O_d_pad_left_sig
	.O_d_pad_right(arrow_right) ,	// output  O_d_pad_right_sig
	.O_square(square) ,	// output  O_square_sig
	.O_triangle(triangle) ,	// output  O_triangle_sig
	.O_circle(circle) ,	// output  O_circle_sig
	.O_x(button_x) ,	// output  O_x_sig
	.O_select(select) ,	// output  O_select_sig
	.O_start(start) ,	// output  O_start_sig
	.O_analog1_left_right(analog1_left_right) ,	// output [7:0] O_left_analog_up_down_sig
	.O_analog2_left_right(analog2_left_right) ,	// output [7:0] O_left_analog_right_left_sig
	.O_analog1_up_down(analog1_up_down) ,	// output [7:0] O_right_analog_up_down_sig
	.O_analog2_up_down(analog2_up_down) ,	// output [7:0] O_right_analog_right_left_sig
	.switches(SW[1:0]) 	// input [1:0] switches_sig
);
	
	assign LED[7:0]= SW[3:2]==2'd0 ? analog1_left_right:
					  SW[3:2]==2'd1 ? analog2_left_right:
					  SW[3:2]==2'd2 ? analog1_up_down:
					  analog2_up_down;
					 

	

	
	

//	
//
//snes_controller snes_controller_inst
//(
//	.clk_166MHz(clk_166) ,	// input  clk_166kHz_sig
//	.sclk(GPIO1[10]) ,	// output  sclk_sig
//	.latch(GPIO1[14]) ,	// output  latch_sig
//	.datain(GPIO1[18]) ,	// input  datain_sig
//	.start(1'b1) ,	// input  start_sig
//	.finish() ,	// output  finish_sig
//	.boton_B(boton_b) ,	// output  boton_B_sig
//	.boton_Y(boton_y) ,	// output  boton_Y_sig
//	.boton_SELECT() ,	// output  boton_SELECT_sig
//	.boton_START() ,	// output  boton_START_sig
//	.boton_UP(boton_up) ,	// output  boton_UP_sig
//	.boton_DOWN(boton_down) ,	// output  boton_DOWN_sig
//	.boton_LEFT(boton_left) ,	// output  boton_LEFT_sig
//	.boton_RIGHT(boton_right) ,	// output  boton_RIGHT_sig
//	.boton_A(boton_a) ,	// output  boton_A_sig
//	.boton_X(boton_x ) ,	// output  boton_X_sig
//	.boton_L(boton_l) ,	// output  boton_L_sig
//	.boton_R(boton_r) 	// output  boton_R_sig
//);

	 

assign GPIO[0]=TFT_RED[7];
assign GPIO[1]=TFT_RED[6];
assign GPIO[3]=TFT_RED[5];
assign GPIO[5]=TFT_RED[4];
assign GPIO[7]=TFT_GREEN[7];
assign GPIO[9]=TFT_GREEN[6];
assign GPIO[11]=TFT_GREEN[5];
assign GPIO[13]=TFT_GREEN[4];
assign GPIO[15]=TFT_BLUE[7];
assign GPIO[17]=TFT_BLUE[6];
assign GPIO[19]=TFT_BLUE[5];
assign GPIO[21]=TFT_BLUE[4];
assign GPIO[23]=TFT_VSYNC;
assign GPIO[25]=TFT_HSYNC;




endmodule
